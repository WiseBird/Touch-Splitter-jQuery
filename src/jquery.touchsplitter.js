// Generated by CoffeeScript 1.10.0

/*
 * Touch Splitter JQuery was created by Cole Lawrence(github:ZombieHippie)
 * This work is licensed under the Creative Commons Attribution-ShareAlike 3.0
 * Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-sa/3.0/.
 */

(function() {
  (function(mod) {
    if (typeof exports === "object" && typeof module === "object") {
      return mod(require("jquery"));
    } else if (typeof define === "function" && define.amd) {
      return define(["jquery"], mod);
    } else {
      return mod(jQuery);
    }
  })(function(jQuery) {
    var $, TouchSplitter;
    $ = jQuery;
    $.fn.touchSplit = function(options) {
      if (options == null) {
        options = {};
      }
      if (this[0].touchSplitter != null) {
        throw "Cannot make a splitter here! '" + this.selector + "' already has a splitter! Use $('" + this.selector + "')[0].touchSplitter.destroy(<optional side to remove>) to remove it!";
      }
      if (this.children().length !== 2 && this.children().length !== 0) {
        throw "Cannot make a splitter here! Incorrect number of div children in '" + this.selector + "'";
      }
      return this[0].touchSplitter = new TouchSplitter(this, options);
    };
    TouchSplitter = (function() {
      function TouchSplitter(element, options) {
        var barThick, firstdiv, inners, match, splitterHTML, testCalc, testEm, thickness, units;
        this.element = element;
        this.element.addClass('TouchSplitter');
        this.support = {};
        testEm = $('<div class="test-em"></div>');
        testEm.appendTo(this.element);
        barThick = testEm.width();
        testEm.remove();
        testCalc = $('<div class="test-calc"></div>');
        testCalc.appendTo(this.element);
        this.support.calc = false;
        testCalc.remove();
        if (options.orientation != null) {
          if (options.orientation === "vertical") {
            this.horizontal = false;
          } else if (options.orientation === "horizontal") {

          } else {
            console.log("Touch Splitter ERROR: orientation cannot be:'" + options.orientation + "' defaulted to 'horizontal'");
          }
        }
        if (this.horizontal !== false) {
          this.horizontal = true;
        }
        this.element.addClass(this.horizontal ? "h-ts" : "v-ts");
        this.firstMin = options.leftMin || options.topMin || options.firstMin || 0;
        this.firstMax = options.leftMax || options.topMax || options.firstMax || false;
        this.secondMin = options.rightMin || options.bottomMin || options.secondMin || 0;
        this.secondMax = options.rightMax || options.bottomMax || options.secondMax || false;
        if (this.firstMax && this.secondMax) {
          console.log("Touch Splitter ERROR: cannot set max bounds of both first and second sections!");
          this.secondMax = false;
        }
        if (options.dock != null) {
          if (/both|left|top|first|right|bottom|second/i.test(options.dock)) {
            this.docks = (function() {
              switch (false) {
                case !/both/i.test(options.dock):
                  return {
                    first: true,
                    second: true,
                    name: "both"
                  };
                case !/left|top|first/i.test(options.dock):
                  return {
                    first: true,
                    second: false,
                    name: "first"
                  };
                case !/right|bottom|second/i.test(options.dock):
                  return {
                    first: false,
                    second: true,
                    name: "second"
                  };
              }
            })();
          }
        }
        if (this.docks) {
          this.element.addClass('docks-' + this.docks.name);
        } else {
          this.docks = {
            first: false,
            second: false,
            name: false
          };
        }
        if (options.thickness != null) {
          thickness = options.thickness;
          units = "px";
          if (typeof thickness === 'string') {
            if (match = thickness.match(/^([\d\.]+)([a-zA-Z]+)$/)) {
              thickness = match[1];
              units = match[2];
            }
            thickness = parseFloat(thickness);
          }
          if (!thickness) {
            throw "Unable to parse given thickness: " + options.thickness;
          } else {
            thickness = (function() {
              switch (units) {
                case "px":
                  return barThick = thickness;
                case "em":
                  return barThick *= thickness;
                default:
                  throw "Invalid unit used in given thickness: " + units;
              }
            })();
          }
        }
        this.startPosition = options.startPosition === 0 ? 0 : options.startPosition ? options.startPosition : 0.5;
        if (this.startPosition < 0 || this.startPosition > 1) {
          throw "Bar starting position out of bounds. Please enter a value larger between 0 and 1";
        }
        firstdiv = this.element.find(">div:first");
        splitterHTML = "<div class=\"splitter-bar\">" + (this.docks.name && this.docks.name.match(/first|second/) ? '<div></div>' : '') + "</div>";
        if (firstdiv.length === 0) {
          inners = this.element.html();
          this.element.html("<div></div> " + splitterHTML + " <div></div>");
          this.element.find(">div:first").html(inners);
        } else {
          firstdiv.after(splitterHTML);
        }
        this.barThicknessPx = barThick / 2;
        this.barThickness = .04;
      }

      return TouchSplitter;

    })();
    this.barPosition = this.startPosition;
    this.dragging = false;
    this.initMouse = 0;
    this.initBarPosition = 0;
    this.resize();
    this.element.on('resize', this.onResize);
    $(window).on('resize', this.onResizeWindow);
    $(window).on('mouseup', this.stopDragging);
    $(window).on('mousemove', this.drag);
    this.element.find('>.splitter-bar').on('mousedown', this.onMouseDown);
    this.element.find('>.splitter-bar').bind('touchstart', this.onTouchStart);
    this.element.on('touchmove', this.onTouchMove);
    this.element.on('touchend', this.onTouchEnd);
    this.element.on('touchleave', this.onTouchEnd);
    this.element.on('touchcancel', this.onTouchEnd);
    return {
      destroy: (function(_this) {
        return function(side) {
          var toRemove;
          _this.element.off('resize');
          $(window).off('resize');
          $(window).off('mouseup');
          $(window).off('mousemove');
          _this.element.find('>.splitter-bar').off('mousedown');
          _this.element.find('>.splitter-bar').off('touchstart');
          _this.element.off('touchmove');
          _this.element.off('touchend');
          _this.element.off('touchleave');
          _this.element.off('touchcancel');
          _this.element.find('>.splitter-bar').remove();
          _this.element.removeClass('TouchSplitter h-ts v-ts docks-first docks-second docks-both');
          if (side != null) {
            toRemove = (function() {
              switch (side) {
                case 'left':
                case 'top':
                  return '>div:first';
                case 'right':
                case 'bottom':
                  return '>div:last';
                case 'both':
                  return '>div';
              }
            })();
            _this.element.find(toRemove).remove();
          }
          _this.element.children().css({
            width: "",
            height: ""
          });
          return delete _this.element[0].touchSplitter;
        };
      })(this),
      setRatios: (function(_this) {
        return function() {
          var conv, ref, val;
          _this.splitDistance = _this.horizontal ? _this.element.width() : _this.element.height();
          ref = {
            firstMin: _this.firstMin,
            firstMax: _this.firstMax,
            secondMin: _this.secondMin,
            secondMax: _this.secondMax
          };
          for (conv in ref) {
            val = ref[conv];
            if (val) {
              _this[conv + 'Ratio'] = val / _this.splitDistance;
            }
          }
          return _this.moveBar();
        };
      })(this),
      toggleDock: (function(_this) {
        return function() {
          _this.element.toggleClass('docked');
          if (_this.docked) {
            return _this.setDock(false);
          } else {
            return _this.setDock(_this.docks.name);
          }
        };
      })(this),
      on: (function(_this) {
        return function(eventName, fn) {
          return _this.element.on(eventName, fn);
        };
      })(this),
      moveBar: (function(_this) {
        return function(newX) {
          var cursorPos, cursorPos2;
          cursorPos = _this.barPosition;
          if (newX != null) {
            cursorPos = _this.initBarPosition + (newX - _this.initMouse) / _this.splitDistance;
          }
          cursorPos2 = 1 - cursorPos;
          if (_this.docks.name) {
            switch (_this.docked) {
              case 'first':
                if (cursorPos > _this.firstMinRatio / 2) {
                  _this.setDock(false);
                }
                break;
              case 'second':
                if (cursorPos2 > _this.secondMinRatio / 2) {
                  _this.setDock(false);
                }
                break;
              default:
                if (_this.docks.first && cursorPos < _this.firstMinRatio / 2) {
                  _this.setDock('first');
                }
                if (_this.docks.second && cursorPos2 < _this.secondMinRatio / 2) {
                  _this.setDock('second');
                }
            }
          }
          if (!_this.docked) {
            _this.barPosition = (function() {
              switch (false) {
                case !(this.firstMaxRatio && cursorPos > this.firstMaxRatio):
                  return this.firstMaxRatio;
                case !(cursorPos < this.firstMinRatio):
                  return this.firstMinRatio;
                case !(this.secondMaxRatio && cursorPos2 > this.secondMaxRatio):
                  return 1 - this.secondMaxRatio;
                case !(cursorPos2 < this.secondMinRatio):
                  return 1 - this.secondMinRatio;
                default:
                  return cursorPos;
              }
            }).call(_this);
            return _this.setPercentages();
          }
        };
      })(this),
      setDock: (function(_this) {
        return function(val, lastpos) {
          if (lastpos == null) {
            lastpos = _this.barPosition;
          }
          _this.docked = val;
          _this.barPosition = _this.lastPosition;
          _this.lastPosition = lastpos;
          return _this.setPercentages();
        };
      })(this),
      setPercentages: (function(_this) {
        return function() {
          var attr, first, firstCss, pos, second, secondCss, shave;
          switch (_this.docked) {
            case 'first':
              _this.barPosition = 0;
              break;
            case 'second':
              _this.barPosition = 1;
          }
          pos = _this.barPosition;
          firstCss = secondCss = "";
          if (!_this.support.calc) {
            if (pos < _this.barThickness) {
              pos = _this.barThickness;
            }
            if (pos > 1 - _this.barThickness) {
              pos = 1 - _this.barThickness;
            }
            first = pos - _this.barThickness;
            second = 1 - pos - _this.barThickness;
            firstCss = (100 * first - _this.barThickness) + "%";
            secondCss = (100 * second - _this.barThickness) + "%";
          } else {
            shave = _this.barThicknessPx;
            if (_this.docked) {
              shave *= 2;
            }
            pos *= 100;
            firstCss = "calc(" + pos + "% - " + shave + "px)";
            secondCss = "calc(" + (100 - pos) + "% - " + shave + "px)";
          }
          attr = _this.horizontal ? "width" : "height";
          _this.getFirst().css(attr, firstCss);
          return _this.getSecond().css(attr, secondCss);
        };
      })(this),
      onMouseDown: (function(_this) {
        return function(event) {
          event.preventDefault();
          _this.initMouse = _this.horizontal ? event.clientX : event.clientY;
          return _this.startDragging(event);
        };
      })(this),
      onTouchStart: (function(_this) {
        return function(event) {
          var orig;
          orig = event.originalEvent;
          _this.initMouse = _this.horizontal ? orig.changedTouches[0].pageX : orig.changedTouches[0].pageY;
          return _this.startDragging(event);
        };
      })(this),
      onTouchMove: (function(_this) {
        return function(event) {
          var orig, page;
          if (!_this.dragging) {
            return;
          }
          event.preventDefault();
          orig = event.originalEvent;
          page = _this.horizontal ? orig.changedTouches[0].pageX : orig.changedTouches[0].pageY;
          return _this.moveBar(page);
        };
      })(this),
      onTouchEnd: (function(_this) {
        return function(event) {
          return _this.stopDragging(event);
        };
      })(this),
      startDragging: (function(_this) {
        return function(event) {
          _this.initBarPosition = _this.barPosition;
          _this.isToggler = !!event.target.parentNode.className.match(/\bsplitter-bar\b/);
          _this.dragging = true;
          return _this.element.trigger("dragstart");
        };
      })(this),
      drag: (function(_this) {
        return function(event) {
          var client, whichM;
          if (!_this.dragging) {
            return;
          }
          whichM = typeof event.buttons !== 'undefined' ? event.buttons : event.which;
          if (whichM === 0) {
            _this.stopDragging();
          }
          client = _this.horizontal ? event.clientX : event.clientY;
          return _this.moveBar(client);
        };
      })(this),
      stopDragging: (function(_this) {
        return function(event) {
          if (_this.dragging) {
            _this.dragging = false;
            _this.element.trigger("dragstop");
            if (_this.isToggler) {
              return setTimeout(function() {
                if ((_this.barPosition - _this.initBarPosition) === 0) {
                  return _this.toggleDock();
                }
              }, 0);
            }
          }
        };
      })(this),
      getFirst: (function(_this) {
        return function() {
          return _this.element.find('>div:first');
        };
      })(this),
      getSecond: (function(_this) {
        return function() {
          return _this.element.find('>div:last');
        };
      })(this),
      onResizeWindow: (function(_this) {
        return function(event) {
          return _this.resize();
        };
      })(this),
      onResize: (function(_this) {
        return function(event) {
          if (event != null) {
            event.stopPropagation();
            if (!$(event.target).is(_this.element)) {
              return;
            }
          }
          return _this.resize();
        };
      })(this),
      resize: (function(_this) {
        return function() {
          var attr;
          _this.setRatios();
          attr = _this.horizontal ? "width" : "height";
          if (!_this.support.calc) {
            _this.barThickness = _this.barThicknessPx / _this.splitDistance;
            if (_this.barThickness > 1) {
              _this.barThickness = 1;
            }
            _this.element.find('>.splitter-bar').css(attr, _this.barThickness * 200 + '%');
          } else {
            _this.barThickness = 0;
          }
          return _this.setPercentages();
        };
      })(this)
    };
  });

}).call(this);

//# sourceMappingURL=jquery.touchsplitter.js.map
